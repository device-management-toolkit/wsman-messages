/*********************************************************************
 * Copyright (c) Intel Corporation 2021
 * SPDX-License-Identifier: Apache-2.0
 **********************************************************************/

import type { Selector } from '../WSMan'
import { Base, WSManMessageCreator } from '../WSMan'
import type { Models, Types } from './'
import { Actions, Classes, Methods } from './'

class IEEE8021xCredentialContext extends Base {
  className = Classes.IEEE8021X_CREDENTIAL_CONTEXT
}
class AlarmClockOccurrence extends Base {
  className = Classes.ALARM_CLOCK_OCCURRENCE
  /**
   * Deletes an instance of AlarmClockOccurrence
   * @param selector Selector Object.
   * @returns string
   */
  Delete = (selector: Selector): string => this.protectedDelete(selector)
}
class HostBasedSetupService extends Base {
  className = Classes.HOST_BASED_SETUP_SERVICE
  /**
   * Add a certificate to the provisioning certificate chain, to be used by AdminSetup or UpgradeClientToAdmin methods.
   * @param cert The next certificate to add to the chain
   * @param isLeaf true, when the current certificate is leaf certificate
   * @param isRoot true, when the current certificate is root. Marks end of the certificate chain
   * @returns string
   */
  AddNextCertInChain = (cert: string, isLeaf: boolean, isRoot: boolean): string => {
    const header: string = this.wsmanMessageCreator.createHeader(
      Actions.ADD_NEXT_CERT_IN_CHAIN,
      Classes.HOST_BASED_SETUP_SERVICE
    )
    const body: string = this.wsmanMessageCreator.createBody(
      'AddNextCertInChain_INPUT',
      Classes.HOST_BASED_SETUP_SERVICE,
      [
        {
          NextCertificate: cert,
          IsLeafCertificate: isLeaf,
          IsRootCertificate: isRoot
        }
      ]
    )
    return this.wsmanMessageCreator.createXml(header, body)
  }

  /**
   * Setup Intel(R) AMT from the local host, resulting in Admin Setup Mode. Requires OS administrator rights, and moves Intel(R) AMT from "Pre Provisioned" state to "Post Provisioned" state. The control mode after this method is run will be "Admin".
   * @param adminPassEncryptionType The encryption type of the network admin password. Only HTTP-MD5 is supported. The values are the same as the CIM_Account.UserPasswordEncryptionAlgorithm field
   * @param adminPassword New network admin password to be set by this command, encrypted using the encryption type algorithm
   * @param mcNonce A random nonce value generated by the configuration agent.Required if the digital signature is provided.needs to be concatenated after the configuration nonce and signed together with the attached certificate's private key
   * @param signingAlgorithm The signing algorithm used to sign the setup operation.
   * @param digitalSignature A digital signature of the ConfigurationNonce and the McNonce concatenated. If this information is provided, AMT will validate the signature before accepting the command.
   * @returns string
   */
  AdminSetup = (
    adminPassEncryptionType: Types.HostBasedSetupService.AdminPassEncryptionType,
    adminPassword: string,
    mcNonce: string,
    signingAlgorithm: Types.HostBasedSetupService.SigningAlgorithm,
    digitalSignature: string
  ): string => {
    const header: string = this.wsmanMessageCreator.createHeader(Actions.ADMIN_SETUP, Classes.HOST_BASED_SETUP_SERVICE)
    const body: string = this.wsmanMessageCreator.createBody('AdminSetup_INPUT', Classes.HOST_BASED_SETUP_SERVICE, [
      {
        NetAdminPassEncryptionType: adminPassEncryptionType,
        NetworkAdminPassword: adminPassword,
        McNonce: mcNonce,
        SigningAlgorithm: signingAlgorithm,
        DigitalSignature: digitalSignature
      }
    ])
    return this.wsmanMessageCreator.createXml(header, body)
  }

  /**
   * Upgrade Intel(R) AMT from Client to Admin Control Mode. Requires AMT administrator rights, and that the machine has been previously provisioned in Client control mode.
   * @param mcNonce A random nonce value generated by the configuration agent.Required if the digital signature is provided.needs to be concatenated after the configuration nonce and signed together with the attached certificate's private key
   * @param signingAlgorithm The signing algorithm used to sign the setup operation.
   * @param digitalSignature A digital signature of the ConfigurationNonce and the McNonce concatenated. If this information is provided, AMT will validate the signature before accepting the command.
   * @returns string
   */
  UpgradeClientToAdmin = (
    mcNonce: string,
    signingAlgorithm: Types.HostBasedSetupService.SigningAlgorithm,
    digitalSignature: string
  ): string => {
    const header: string = this.wsmanMessageCreator.createHeader(
      Actions.UPGRADE_CLIENT_TO_ADMIN,
      Classes.HOST_BASED_SETUP_SERVICE
    )
    const body: string = this.wsmanMessageCreator.createBody(
      'UpgradeClientToAdmin_INPUT',
      Classes.HOST_BASED_SETUP_SERVICE,
      [
        {
          McNonce: mcNonce,
          SigningAlgorithm: signingAlgorithm,
          DigitalSignature: digitalSignature
        }
      ]
    )
    return this.wsmanMessageCreator.createXml(header, body)
  }

  /**
   * Setup Intel(R) AMT from local host. This function requires OS administrator rights, and moves Intel(R) AMT from "Pre Provisioned" state to "Post Provisioned" state. The control mode after this method is run will be "Client". This method also allows the configuring agent to sign the setup operation with a certificate. The certificate hash will be kept in the corresponding provisioning record
   * @param adminPassEncryptionType The encryption type of the network admin password. Only HTTP-MD5 is supported. The values are the same as the CIM_Account.UserPasswordEncryptionAlgorithm field
   * @param adminPassword New network admin password to be set by this command, encrypted using the encryption type algorithm
   * @returns string
   */
  Setup = (
    adminPassEncryptionType: Types.HostBasedSetupService.AdminPassEncryptionType,
    adminPassword: string
  ): string => {
    const header: string = this.wsmanMessageCreator.createHeader(Actions.SETUP, Classes.HOST_BASED_SETUP_SERVICE)
    const body: string = this.wsmanMessageCreator.createBody('Setup_INPUT', Classes.HOST_BASED_SETUP_SERVICE, [
      {
        NetAdminPassEncryptionType: adminPassEncryptionType.toString(),
        NetworkAdminPassword: adminPassword
      }
    ])
    return this.wsmanMessageCreator.createXml(header, body)
  }
}
class IEEE8021xSettings extends Base {
  className = Classes.IEEE8021X_SETTINGS
  /**
   * Changes properties of IEEE8021xSettings.
   * @param ieee8021xSettings IEEE8021xSettings Object
   * @returns string
   */
  Put = (ieee8021xSettings: Models.IEEE8021xSettings): string => this.protectedPut(ieee8021xSettings, false)
  /**
   * Sets certificates for IEEE8021xSettings in AMT
   * @param serverCertificateIssuer AMT_PublicKeyCertificate Object
   * @param clientCertificate AMT_PublicKeyCertificate Object
   * @returns string
   */
  SetCertificates = (serverCertificateIssuer: string, clientCertificate: string): string => {
    const header: string = this.wsmanMessageCreator.createHeader(
      Actions.SET_CERTIFICATES,
      Classes.IEEE8021X_SETTINGS,
      undefined,
      undefined
    )
    const body: string = this.wsmanMessageCreator.createBody(
      Methods.SET_CERTIFICATES_INPUT,
      Classes.IEEE8021X_SETTINGS,
      [
        {
          ServerCertificateIssuer: serverCertificateIssuer,
          ClientCertificate: clientCertificate
        }
      ]
    )
    return this.wsmanMessageCreator.createXml(header, body)
  }
}
class OptInService extends Base {
  className = Classes.OPT_IN_SERVICE
  /**
   * Cancel a previous opt-in code request.
   * @returns string
   */
  CancelOptIn = (): string => {
    const header = this.wsmanMessageCreator.createHeader(Actions.CANCEL_OPT_IN, Classes.OPT_IN_SERVICE)
    const body = this.wsmanMessageCreator.createBody('CancelOptIn_INPUT', Classes.OPT_IN_SERVICE)
    return this.wsmanMessageCreator.createXml(header, body)
  }

  /**
   * Changes properties of OptInService.
   * @param optInServiceResponse OptInServiceResponse Object
   * @returns string
   */
  Put = (optInServiceResponse: Models.OptInServiceResponse): string => {
    const key = Object.keys(optInServiceResponse)[0]
    return this.protectedPut(optInServiceResponse[key], false)
  }

  /**
   * Send the opt-in code to Intel(R) AMT.
   * @param optInCode The opt-in code generated by Intel(R) AMT. This code is displayed on the user screen and should be entered by the remote IT technician.
   * @returns string
   */
  SendOptInCode = (optInCode: number): string => {
    const header = this.wsmanMessageCreator.createHeader(Actions.SEND_OPT_IN_CODE, Classes.OPT_IN_SERVICE)
    const body = this.wsmanMessageCreator.createBody('SendOptInCode_INPUT', Classes.OPT_IN_SERVICE, [
      { OptInCode: optInCode }])
    return this.wsmanMessageCreator.createXml(header, body)
  }

  /**
   * Request an opt-in code
   * @returns string
   */
  StartOptIn = (): string => {
    const header = this.wsmanMessageCreator.createHeader(Actions.START_OPT_IN, Classes.OPT_IN_SERVICE)
    const body = this.wsmanMessageCreator.createBody('StartOptIn_INPUT', Classes.OPT_IN_SERVICE)
    return this.wsmanMessageCreator.createXml(header, body)
  }
}
class PowerManagementService extends Base {
  className = Classes.POWER_MANAGEMENT_SERVICE
  /**
   * Define the desired OS power saving state of the managed element, and when the element should be put into that state
   * @param OSPowerSavingState indicates the desired OS power saving state
   * @returns string
   */
  RequestOSPowerSavingStateChange = (OSPowerSavingState: Types.PowerManagementService.OSPowerSavingState): string => {
    const header: string = this.wsmanMessageCreator.createHeader(
      Actions.REQUEST_OS_POWER_SAVING_STATE_CHANGE,
      Classes.POWER_MANAGEMENT_SERVICE
    )

    const body = `<Body><h:RequestOSPowerSavingStateChange_INPUT xmlns:h="http://intel.com/wbem/wscim/1/ips-schema/1/IPS_PowerManagementService"><h:OSPowerSavingState>${OSPowerSavingState}</h:OSPowerSavingState><h:ManagedElement><Address xmlns="http://schemas.xmlsoap.org/ws/2004/08/addressing">http://schemas.xmlsoap.org/ws/2004/08/addressing</Address><ReferenceParameters xmlns="http://schemas.xmlsoap.org/ws/2004/08/addressing"><ResourceURI xmlns="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd">http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ComputerSystem</ResourceURI><SelectorSet xmlns="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"><Selector Name="CreationClassName">CIM_ComputerSystem</Selector><Selector Name="Name">ManagedSystem</Selector></SelectorSet></ReferenceParameters></h:ManagedElement></h:RequestOSPowerSavingStateChange_INPUT></Body>`
    return this.wsmanMessageCreator.createXml(header, body)
  }
}

class HTTPProxyService extends Base {
  className = Classes.HTTP_PROXY_SERVICE

  AddProxyAccessPoint = (addProxyAccessPointParameters: Models.AddProxyAccessPointParameters): string => {
    const header = this.wsmanMessageCreator.createHeader(Actions.ADD_PROXY_ACCESS_POINT, Classes.HTTP_PROXY_SERVICE)
    const body = this.wsmanMessageCreator.createBody('AddProxyAccessPoint_INPUT', Classes.HTTP_PROXY_SERVICE, [
      { AccessInfo: addProxyAccessPointParameters.AccessInfo },
      { InfoFormat: addProxyAccessPointParameters.InfoFormat },
      { Port: addProxyAccessPointParameters.Port },
      { NetworkDnsSuffix: addProxyAccessPointParameters.NetworkDnsSuffix }])
    return this.wsmanMessageCreator.createXml(header, body)
  }
}

class ScreenSettingData extends Base {
  className = Classes.SCREEN_SETTING_DATA
}

class KVMRedirectionSettingData extends Base {
  className = Classes.KVM_REDIRECTION_SETTING_DATA

  Put = (data: Models.KVMRedirectionSettingData): string => this.protectedPut(data, false)
}

class HTTPProxyAccessPoint extends Base {
  className = Classes.HTTP_PROXY_ACCESS_POINT
  /**
   * Sets proxy priority to highest priority.
   * @returns string
   */
  UpdatePriority = (): string => {
    const header = this.wsmanMessageCreator.createHeader(Actions.UPDATE_PRIORITY, Classes.HTTP_PROXY_ACCESS_POINT)
    const body = this.wsmanMessageCreator.createBody('UpdatePriority_INPUT', Classes.HTTP_PROXY_ACCESS_POINT)
    return this.wsmanMessageCreator.createXml(header, body)
  }

  /**
   * Deletes an instance of HTTPProxyAccessPoint
   * @param selector Selector Object.
   * @returns string
   */
  Delete = (selector: Selector): string => this.protectedDelete(selector)
}

export class Messages {
  readonly resourceUriBase: string = 'http://intel.com/wbem/wscim/1/ips-schema/1/'
  wsmanMessageCreator: WSManMessageCreator = new WSManMessageCreator(this.resourceUriBase)
  public IEEE8021xCredentialContext = new IEEE8021xCredentialContext(this.wsmanMessageCreator)
  public AlarmClockOccurrence = new AlarmClockOccurrence(this.wsmanMessageCreator)
  public HostBasedSetupService = new HostBasedSetupService(this.wsmanMessageCreator)
  public IEEE8021xSettings = new IEEE8021xSettings(this.wsmanMessageCreator)
  public OptInService = new OptInService(this.wsmanMessageCreator)
  public PowerManagementService = new PowerManagementService(this.wsmanMessageCreator)
  public HTTPProxyService = new HTTPProxyService(this.wsmanMessageCreator)
  public ScreenSettingData = new ScreenSettingData(this.wsmanMessageCreator)
  public KVMRedirectionSettingData = new KVMRedirectionSettingData(this.wsmanMessageCreator)
  public HTTPProxyAccessPoint = new HTTPProxyAccessPoint(this.wsmanMessageCreator)
}
